import { jsx as Pt } from "react/jsx-runtime";
import { createContext as ne, useContext as re, useState as rt, useEffect as S, useRef as bt, useCallback as ie, useMemo as oe } from "react";
var ae = Object.defineProperty, ce = (e, t, s) => t in e ? ae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, c = (e, t, s) => (ce(e, typeof t != "symbol" ? t + "" : t, s), s);
function St(e, t) {
  let s;
  const n = () => {
    s !== void 0 && t && t(s), s = void 0;
  };
  return [() => s === void 0 ? s = e(n) : s, n];
}
function Rt(e) {
  const t = j(), { count: s } = t;
  t.unsubscribe(e), s && !t.count && Ce();
}
function he(e) {
  return j().subscribe(e), () => Rt(e);
}
class pe {
  constructor(t, s = {}) {
    this.scope = t, this.options = s;
  }
  /**
   * Prints message into a console in case, logger is currently enabled.
   * @param level - log level.
   * @param args - arguments.
   */
  print(t, ...s) {
    const n = /* @__PURE__ */ new Date(), r = Intl.DateTimeFormat("en-GB", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      fractionalSecondDigits: 3,
      timeZone: "UTC"
    }).format(n), { textColor: i, bgColor: o } = this.options, a = "font-weight: bold;padding: 0 5px;border-radius:5px";
    console[t](
      `%c${r}%c / %c${this.scope}`,
      `${a};background-color: lightblue;color:black`,
      "",
      `${a};${i ? `color:${i};` : ""}${o ? `background-color:${o}` : ""}`,
      ...s
    );
  }
  /**
   * Prints error message into a console.
   * @param args
   */
  error(...t) {
    this.print("error", ...t);
  }
  /**
   * Prints log message into a console.
   * @param args
   */
  log(...t) {
    this.print("log", ...t);
  }
}
const it = new pe("SDK", {
  bgColor: "forestgreen",
  textColor: "white"
});
let X = !1;
const mt = ({ name: e, payload: t }) => {
  it.log("Event received:", t ? { name: e, payload: t } : { name: e });
};
function ue(e) {
  X !== e && (X = e, e ? he(mt) : Rt(mt));
}
function le(...e) {
  X && it.log(...e);
}
class D {
  constructor() {
    c(this, "listeners", /* @__PURE__ */ new Map()), c(this, "listenersCount", 0), c(this, "subscribeListeners", []);
  }
  /**
   * Removes all event listeners.
   */
  clear() {
    this.listeners.clear(), this.subscribeListeners = [];
  }
  /**
   * Returns count of bound listeners.
   */
  get count() {
    return this.listenersCount + this.subscribeListeners.length;
  }
  emit(t, ...s) {
    this.subscribeListeners.forEach((n) => n({
      event: t,
      args: s
    })), (this.listeners.get(t) || []).forEach(([n, r]) => {
      n(...s), r && this.off(t, n);
    });
  }
  /**
   * Adds new event listener.
   * @param event - event name.
   * @param listener - event listener.
   * @param once - should listener be called only once.
   * @returns Function to remove bound event listener.
   */
  on(t, s, n) {
    let r = this.listeners.get(t);
    return r || this.listeners.set(t, r = []), r.push([s, n]), this.listenersCount += 1, () => this.off(t, s);
  }
  /**
   * Removes event listener. In case, specified listener was bound several times, it removes
   * only a single one.
   * @param event - event name.
   * @param listener - event listener.
   */
  off(t, s) {
    const n = this.listeners.get(t) || [];
    for (let r = 0; r < n.length; r += 1)
      if (s === n[r][0]) {
        n.splice(r, 1), this.listenersCount -= 1;
        return;
      }
  }
  /**
   * Adds a new event listener for all events.
   * @param listener - event listener.
   * @returns Function to remove event listener.
   */
  subscribe(t) {
    return this.subscribeListeners.push(t), () => this.unsubscribe(t);
  }
  /**
   * Removes global event listener. In case, specified listener was bound several times, it removes
   * only a single one.
   * @param listener - event listener.
   */
  unsubscribe(t) {
    for (let s = 0; s < this.subscribeListeners.length; s += 1)
      if (this.subscribeListeners[s] === t) {
        this.subscribeListeners.splice(s, 1);
        return;
      }
  }
}
function tt(e, t, s) {
  return window.addEventListener(e, t, s), () => window.removeEventListener(e, t, s);
}
function ot(...e) {
  let t = !1;
  const s = e.flat(1);
  return [
    (n) => !t && s.push(n),
    () => {
      t || (t = !0, s.forEach((n) => n()));
    },
    t
  ];
}
class W extends Error {
  constructor(t, s, n) {
    super(s, { cause: n }), this.type = t, Object.setPrototypeOf(this, W.prototype);
  }
}
function b(e, t, s) {
  return new W(e, t, s);
}
const de = "ERR_METHOD_UNSUPPORTED", _e = "ERR_METHOD_PARAMETER_UNSUPPORTED", we = "ERR_UNKNOWN_ENV", ge = "ERR_INVOKE_CUSTOM_METHOD_RESPONSE", fe = "ERR_TIMED_OUT", be = "ERR_UNEXPECTED_TYPE", xt = "ERR_PARSE", me = "ERR_NAVIGATION_LIST_EMPTY", ve = "ERR_NAVIGATION_CURSOR_INVALID", bn = "ERR_NAVIGATION_ITEM_INVALID", mn = "ERR_SSR_INIT", ye = "ERR_INVALID_PATH_BASE";
function T() {
  return b(be, "Value has unexpected type");
}
class G {
  constructor(t, s, n) {
    this.parser = t, this.isOptional = s, this.type = n;
  }
  /**
   * Attempts to parse passed value
   * @param value - value to parse.
   * @throws {SDKError} ERR_PARSE
   * @see ERR_PARSE
   */
  parse(t) {
    if (!(this.isOptional && t === void 0))
      try {
        return this.parser(t);
      } catch (s) {
        throw b(
          xt,
          `Unable to parse value${this.type ? ` as ${this.type}` : ""}`,
          s
        );
      }
  }
  optional() {
    return this.isOptional = !0, this;
  }
}
function A(e, t) {
  return () => new G(e, !1, t);
}
const E = A((e) => {
  if (typeof e == "boolean")
    return e;
  const t = String(e);
  if (t === "1" || t === "true")
    return !0;
  if (t === "0" || t === "false")
    return !1;
  throw T();
}, "boolean");
function Ct(e, t) {
  const s = {};
  for (const n in e) {
    const r = e[n];
    if (!r)
      continue;
    let i, o;
    if (typeof r == "function" || "parse" in r)
      i = n, o = typeof r == "function" ? r : r.parse.bind(r);
    else {
      const { type: a } = r;
      i = r.from || n, o = typeof a == "function" ? a : a.parse.bind(a);
    }
    try {
      const a = o(t(i));
      a !== void 0 && (s[n] = a);
    } catch (a) {
      throw b(xt, `Unable to parse field "${n}"`, a);
    }
  }
  return s;
}
function Tt(e) {
  let t = e;
  if (typeof t == "string" && (t = JSON.parse(t)), typeof t != "object" || t === null || Array.isArray(t))
    throw T();
  return t;
}
function v(e, t) {
  return new G((s) => {
    const n = Tt(s);
    return Ct(e, (r) => n[r]);
  }, !1, t);
}
const R = A((e) => {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = Number(e);
    if (!Number.isNaN(t))
      return t;
  }
  throw T();
}, "number"), u = A((e) => {
  if (typeof e == "string" || typeof e == "number")
    return e.toString();
  throw T();
}, "string");
function At(e) {
  return v({
    eventType: u(),
    eventData: (t) => t
  }).parse(e);
}
function Ee() {
  ["TelegramGameProxy_receiveEvent", "TelegramGameProxy", "Telegram"].forEach((e) => {
    delete window[e];
  });
}
function et(e, t) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: e, eventData: t }),
    // We specify window.parent to imitate the case, the parent iframe sent us this event.
    source: window.parent
  }));
}
function Pe() {
  [
    ["TelegramGameProxy_receiveEvent"],
    // Windows Phone.
    ["TelegramGameProxy", "receiveEvent"],
    // Desktop.
    ["Telegram", "WebView", "receiveEvent"]
    // Android and iOS.
  ].forEach((e) => {
    let t = window;
    e.forEach((s, n, r) => {
      if (n === r.length - 1) {
        t[s] = et;
        return;
      }
      s in t || (t[s] = {}), t = t[s];
    });
  });
}
const Se = {
  clipboard_text_received: v({
    req_id: u(),
    data: (e) => e === null ? e : u().optional().parse(e)
  }),
  custom_method_invoked: v({
    req_id: u(),
    result: (e) => e,
    error: u().optional()
  }),
  popup_closed: {
    parse(e) {
      return v({
        button_id: (t) => t == null ? void 0 : u().parse(t)
      }).parse(e ?? {});
    }
  },
  viewport_changed: v({
    height: R(),
    width: (e) => e == null ? window.innerWidth : R().parse(e),
    is_state_stable: E(),
    is_expanded: E()
  })
};
function Re() {
  const e = new D(), t = new D();
  t.subscribe((n) => {
    e.emit("event", { name: n.event, payload: n.args[0] });
  }), Pe();
  const [, s] = ot(
    // Don't forget to remove created handlers.
    Ee,
    // Add "resize" event listener to make sure, we always have fresh viewport information.
    // Desktop version of Telegram is sometimes not sending the viewport_changed
    // event. For example, when the MainButton is shown. That's why we should
    // add our own listener to make sure, viewport information is always fresh.
    // Issue: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/10
    tt("resize", () => {
      t.emit("viewport_changed", {
        width: window.innerWidth,
        height: window.innerHeight,
        is_state_stable: !0,
        is_expanded: !0
      });
    }),
    // Add listener, which handles events sent from the Telegram web application and also events
    // generated by the local emitEvent function.
    tt("message", (n) => {
      if (n.source !== window.parent)
        return;
      let r;
      try {
        r = At(n.data);
      } catch {
        return;
      }
      const { eventType: i, eventData: o } = r, a = Se[i];
      try {
        const h = a ? a.parse(o) : o;
        t.emit(...h ? [i, h] : [i]);
      } catch (h) {
        it.error(
          `An error occurred processing the "${i}" event from the Telegram application.
Please, file an issue here:
https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose`,
          r,
          h
        );
      }
    }),
    // Clear emitters.
    () => e.clear(),
    () => t.clear()
  );
  return [{
    on: t.on.bind(t),
    off: t.off.bind(t),
    subscribe(n) {
      return e.on("event", n);
    },
    unsubscribe(n) {
      e.off("event", n);
    },
    get count() {
      return t.count + e.count;
    }
  }, s];
}
const [xe, Ce] = St(
  (e) => {
    const [t, s] = Re(), n = t.off.bind(t);
    return t.off = (r, i) => {
      const { count: o } = t;
      n(r, i), o && !t.count && e();
    }, [t, s];
  },
  ([, e]) => e()
);
function j() {
  return xe()[0];
}
function z(e, t) {
  j().off(e, t);
}
function y(e, t, s) {
  return j().on(e, t, s);
}
function $(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
function Te(e, t) {
  const s = e.split("."), n = t.split("."), r = Math.max(s.length, n.length);
  for (let i = 0; i < r; i += 1) {
    const o = parseInt(s[i] || "0", 10), a = parseInt(n[i] || "0", 10);
    if (o !== a)
      return o > a ? 1 : -1;
  }
  return 0;
}
function f(e, t) {
  return Te(e, t) <= 0;
}
function x(e, t, s) {
  if (typeof s == "string") {
    if (e === "web_app_open_link") {
      if (t === "try_instant_view")
        return f("6.4", s);
      if (t === "try_browser")
        return f("7.6", s);
    }
    if (e === "web_app_set_header_color" && t === "color")
      return f("6.9", s);
    if (e === "web_app_close" && t === "return_back")
      return f("7.6", s);
  }
  switch (e) {
    case "web_app_open_tg_link":
    case "web_app_open_invoice":
    case "web_app_setup_back_button":
    case "web_app_set_background_color":
    case "web_app_set_header_color":
    case "web_app_trigger_haptic_feedback":
      return f("6.1", t);
    case "web_app_open_popup":
      return f("6.2", t);
    case "web_app_close_scan_qr_popup":
    case "web_app_open_scan_qr_popup":
    case "web_app_read_text_from_clipboard":
      return f("6.4", t);
    case "web_app_switch_inline_query":
      return f("6.7", t);
    case "web_app_invoke_custom_method":
    case "web_app_request_write_access":
    case "web_app_request_phone":
      return f("6.9", t);
    case "web_app_setup_settings_button":
      return f("6.10", t);
    case "web_app_biometry_get_info":
    case "web_app_biometry_open_settings":
    case "web_app_biometry_request_access":
    case "web_app_biometry_request_auth":
    case "web_app_biometry_update_token":
      return f("7.2", t);
    case "web_app_setup_swipe_behavior":
      return f("7.7", t);
    default:
      return [
        "iframe_ready",
        "iframe_will_reload",
        "web_app_close",
        "web_app_data_send",
        "web_app_expand",
        "web_app_open_link",
        "web_app_ready",
        "web_app_request_theme",
        "web_app_request_viewport",
        "web_app_setup_main_button",
        "web_app_setup_closing_behavior"
      ].includes(e);
  }
}
function kt(e) {
  return "external" in e && $(e.external) && "notify" in e.external && typeof e.external.notify == "function";
}
function It(e) {
  return "TelegramWebviewProxy" in e && $(e.TelegramWebviewProxy) && "postEvent" in e.TelegramWebviewProxy && typeof e.TelegramWebviewProxy.postEvent == "function";
}
function at() {
  try {
    return window.self !== window.top;
  } catch {
    return !0;
  }
}
const Ae = "https://web.telegram.org";
let Ot = Ae;
function vn(e) {
  Ot = e;
}
function ke() {
  return Ot;
}
function B(e, t, s) {
  let n = {}, r;
  if (!t && !s ? n = {} : t && s ? (n = s, r = t) : t && ("targetOrigin" in t ? n = t : r = t), le("Posting event:", r ? { event: e, data: r } : { event: e }), at())
    return window.parent.postMessage(
      JSON.stringify({ eventType: e, eventData: r }),
      n.targetOrigin || ke()
    );
  if (kt(window)) {
    window.external.notify(JSON.stringify({ eventType: e, eventData: r }));
    return;
  }
  if (It(window)) {
    window.TelegramWebviewProxy.postEvent(e, JSON.stringify(r));
    return;
  }
  throw b(
    we,
    "Unable to determine current environment and possible way to send event. You are probably trying to use Mini Apps method outside the Telegram application environment."
  );
}
function Ie(e) {
  return (t, s) => {
    if (!x(t, e))
      throw b(de, `Method "${t}" is unsupported in Mini Apps version ${e}`);
    if ($(s) && t === "web_app_set_header_color" && "color" in s && !x(t, "color", e))
      throw b(
        _e,
        `Parameter "color" of "${t}" method is unsupported in Mini Apps version ${e}`
      );
    return B(t, s);
  };
}
function qt(e) {
  return ({ req_id: t }) => t === e;
}
function Vt(e) {
  return b(fe, `Timeout reached: ${e}ms`);
}
function Nt(e, t) {
  return Promise.race([
    typeof e == "function" ? e() : e,
    new Promise((s, n) => {
      setTimeout(() => {
        n(Vt(t));
      }, t);
    })
  ]);
}
async function w(e) {
  let t;
  const s = new Promise((a) => t = a), { event: n, capture: r, timeout: i } = e, [, o] = ot(
    // We need to iterate over all tracked events, and create their event listeners.
    (Array.isArray(n) ? n : [n]).map((a) => y(a, (h) => {
      (!r || (Array.isArray(n) ? r({
        event: a,
        payload: h
      }) : r(h))) && t(h);
    }))
  );
  try {
    return (e.postEvent || B)(e.method, e.params), await (i ? Nt(s, i) : s);
  } finally {
    o();
  }
}
async function V(e, t, s, n = {}) {
  const {
    result: r,
    error: i
  } = await w({
    ...n,
    method: "web_app_invoke_custom_method",
    event: "custom_method_invoked",
    params: {
      method: e,
      params: t,
      req_id: s
    },
    capture: qt(s)
  });
  if (i)
    throw b(ge, i);
  return r;
}
function st(...e) {
  return e.map((t) => {
    if (typeof t == "string")
      return t;
    if ($(t))
      return st(Object.entries(t).map((s) => s[1] && s[0]));
    if (Array.isArray(t))
      return st(...t);
  }).filter(Boolean).join(" ");
}
function yn(...e) {
  return e.reduce((t, s) => ($(s) && Object.entries(s).forEach(([n, r]) => {
    const i = st(t[n], r);
    i.length && (t[n] = i);
  }), t), {});
}
function ct(e) {
  return /^#[\da-f]{6}$/i.test(e);
}
function Oe(e) {
  return /^#[\da-f]{3}$/i.test(e);
}
function Dt(e) {
  const t = e.replace(/\s/g, "").toLowerCase();
  if (ct(t))
    return t;
  if (Oe(t)) {
    let n = "#";
    for (let r = 0; r < 3; r += 1)
      n += t[1 + r].repeat(2);
    return n;
  }
  const s = t.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!s)
    throw new Error(`Value "${e}" does not satisfy any of known RGB formats.`);
  return s.slice(1).reduce((n, r) => {
    const i = parseInt(r, 10).toString(16);
    return n + (i.length === 1 ? "0" : "") + i;
  }, "#");
}
function Bt(e) {
  const t = Dt(e);
  return Math.sqrt(
    [0.299, 0.587, 0.114].reduce((s, n, r) => {
      const i = parseInt(t.slice(1 + r * 2, 1 + (r + 1) * 2), 16);
      return s + i * i * n;
    }, 0)
  ) < 120;
}
class qe {
  constructor(t) {
    c(this, "ee", new D()), c(this, "on", this.ee.on.bind(this.ee)), c(this, "off", this.ee.off.bind(this.ee)), this.state = t;
  }
  /**
   * Clones current state and returns its copy.
   */
  clone() {
    return { ...this.state };
  }
  set(t, s) {
    Object.entries(typeof t == "string" ? { [t]: s } : t).reduce((n, [r, i]) => this.state[r] === i || i === void 0 ? n : (this.state[r] = i, this.ee.emit(`change:${r}`, i), !0), !1) && this.ee.emit("change", this.state);
  }
  /**
   * Returns value by specified key.
   * @param key - state key.
   */
  get(t) {
    return this.state[t];
  }
}
class ht {
  constructor(t) {
    c(this, "state"), c(this, "get"), c(this, "set"), c(this, "clone"), this.state = new qe(t), this.set = this.state.set.bind(this.state), this.get = this.state.get.bind(this.state), this.clone = this.state.clone.bind(this.state);
  }
}
function Mt(e, t) {
  return (s) => x(t[s], e);
}
class pt extends ht {
  constructor(t, s, n) {
    super(t), c(this, "supports"), this.supports = Mt(s, n);
  }
}
class Ve extends pt {
  constructor(t, s, n) {
    super({ isVisible: t }, s, {
      show: "web_app_setup_back_button",
      hide: "web_app_setup_back_button"
    }), c(this, "on", (r, i) => r === "click" ? y("back_button_pressed", i) : this.state.on(r, i)), c(this, "off", (r, i) => r === "click" ? z("back_button_pressed", i) : this.state.off(r, i)), this.postEvent = n;
  }
  set isVisible(t) {
    this.set("isVisible", t), this.postEvent("web_app_setup_back_button", { is_visible: t });
  }
  /**
   * True if BackButton is currently visible.
   */
  get isVisible() {
    return this.get("isVisible");
  }
  /**
   * Hides the BackButton.
   */
  hide() {
    this.isVisible = !1;
  }
  /**
   * Shows the BackButton.
   */
  show() {
    this.isVisible = !0;
  }
}
const Lt = A((e) => e instanceof Date ? e : new Date(R().parse(e) * 1e3), "Date");
function ut(e, t) {
  return new G((s) => {
    if (typeof s != "string" && !(s instanceof URLSearchParams))
      throw T();
    const n = typeof s == "string" ? new URLSearchParams(s) : s;
    return Ct(e, (r) => {
      const i = n.get(r);
      return i === null ? void 0 : i;
    });
  }, !1, t);
}
const Ne = v({
  id: R(),
  type: u(),
  title: u(),
  photoUrl: {
    type: u().optional(),
    from: "photo_url"
  },
  username: u().optional()
}, "Chat").optional(), vt = v({
  addedToAttachmentMenu: {
    type: E().optional(),
    from: "added_to_attachment_menu"
  },
  allowsWriteToPm: {
    type: E().optional(),
    from: "allows_write_to_pm"
  },
  firstName: {
    type: u(),
    from: "first_name"
  },
  id: R(),
  isBot: {
    type: E().optional(),
    from: "is_bot"
  },
  isPremium: {
    type: E().optional(),
    from: "is_premium"
  },
  languageCode: {
    type: u().optional(),
    from: "language_code"
  },
  lastName: {
    type: u().optional(),
    from: "last_name"
  },
  photoUrl: {
    type: u().optional(),
    from: "photo_url"
  },
  username: u().optional()
}, "User").optional();
function $t() {
  return ut({
    authDate: {
      type: Lt(),
      from: "auth_date"
    },
    canSendAfter: {
      type: R().optional(),
      from: "can_send_after"
    },
    chat: Ne,
    chatInstance: {
      type: u().optional(),
      from: "chat_instance"
    },
    chatType: {
      type: u().optional(),
      from: "chat_type"
    },
    hash: u(),
    queryId: {
      type: u().optional(),
      from: "query_id"
    },
    receiver: vt,
    startParam: {
      type: u().optional(),
      from: "start_param"
    },
    user: vt
  }, "InitData");
}
const De = A((e) => Dt(u().parse(e)), "rgb");
function Be(e) {
  return e.replace(/_[a-z]/g, (t) => t[1].toUpperCase());
}
function Me(e) {
  return e.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`);
}
const Ht = A(
  (e) => {
    const t = De().optional();
    return Object.entries(Tt(e)).reduce((s, [n, r]) => (s[Be(n)] = t.parse(r), s), {});
  },
  "ThemeParams"
);
function lt(e) {
  return ut({
    botInline: {
      type: E().optional(),
      from: "tgWebAppBotInline"
    },
    initData: {
      type: $t().optional(),
      from: "tgWebAppData"
    },
    initDataRaw: {
      type: u().optional(),
      from: "tgWebAppData"
    },
    platform: {
      type: u(),
      from: "tgWebAppPlatform"
    },
    showSettings: {
      type: E().optional(),
      from: "tgWebAppShowSettings"
    },
    startParam: {
      type: u().optional(),
      from: "tgWebAppStartParam"
    },
    themeParams: {
      type: Ht(),
      from: "tgWebAppThemeParams"
    },
    version: {
      type: u(),
      from: "tgWebAppVersion"
    }
  }).parse(e);
}
function Ut(e) {
  return lt(
    e.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&")
  );
}
function Le() {
  return Ut(window.location.href);
}
function Wt() {
  return performance.getEntriesByType("navigation")[0];
}
function $e() {
  const e = Wt();
  if (!e)
    throw new Error("Unable to get first navigation entry.");
  return Ut(e.name);
}
function Gt(e) {
  return `telegram-apps/${e.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`)}`;
}
function jt(e, t) {
  sessionStorage.setItem(Gt(e), JSON.stringify(t));
}
function zt(e) {
  const t = sessionStorage.getItem(Gt(e));
  try {
    return t ? JSON.parse(t) : void 0;
  } catch {
  }
}
function He() {
  return lt(zt("launchParams") || "");
}
function Kt(e) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(e).map(([t, s]) => [Me(t), s])
    )
  );
}
function Ue(e) {
  const {
    initDataRaw: t,
    themeParams: s,
    platform: n,
    version: r,
    showSettings: i,
    startParam: o,
    botInline: a
  } = e, h = new URLSearchParams();
  return h.set("tgWebAppPlatform", n), h.set("tgWebAppThemeParams", Kt(s)), h.set("tgWebAppVersion", r), t && h.set("tgWebAppData", t), o && h.set("tgWebAppStartParam", o), typeof i == "boolean" && h.set("tgWebAppShowSettings", i ? "1" : "0"), typeof a == "boolean" && h.set("tgWebAppBotInline", a ? "1" : "0"), h.toString();
}
function Jt(e) {
  jt("launchParams", Ue(e));
}
function nt() {
  const e = [];
  for (const t of [
    // Try to retrieve launch parameters from the current location. This method can return
    // nothing in case, location was changed, and then the page was reloaded.
    Le,
    // Then, try using the lower level API - window.performance.
    $e,
    // Finally, try to extract launch parameters from the session storage.
    He
  ])
    try {
      const s = t();
      return Jt(s), s;
    } catch (s) {
      e.push(s instanceof Error ? s.message : JSON.stringify(s));
    }
  throw new Error([
    `Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?
`,
    "📖 Refer to docs for more information:",
    `https://docs.telegram-mini-apps.com/packages/telegram-apps-sdk/environment
`,
    "Collected errors:",
    e.map((t) => `— ${t}`)
  ].join(`
`));
}
function Ft() {
  const e = Wt();
  return !!(e && e.type === "reload");
}
function We() {
  let e = 0;
  return () => (e += 1).toString();
}
const [Ge] = St(We);
function l(e, t) {
  return () => {
    const s = nt(), n = {
      ...s,
      postEvent: Ie(s.version),
      createRequestId: Ge()
    };
    if (typeof e == "function")
      return e(n);
    const [r, i, o] = ot(), a = t({
      ...n,
      // State should only be passed only in case, current page was reloaded. If we don't add
      // this check, state restoration will work improperly in the web version of Telegram,
      // when we are always working in the same "session" (tab).
      state: Ft() ? zt(e) : void 0,
      addCleanup: r
    }), h = (p) => (o || r(
      p.on("change", (C) => {
        jt(e, C);
      })
    ), p);
    return [
      a instanceof Promise ? a.then(h) : h(a),
      i
    ];
  };
}
const je = l("backButton", ({
  postEvent: e,
  version: t,
  state: s = { isVisible: !1 }
}) => new Ve(s.isVisible, t, e));
class k extends pt {
  constructor() {
    super(...arguments), c(this, "on", this.state.on.bind(this.state)), c(this, "off", this.state.off.bind(this.state));
  }
}
function Qt(e) {
  const t = e.available ? e : {
    available: !1,
    device_id: "",
    token_saved: !1,
    access_requested: !1,
    access_granted: !1,
    type: ""
  };
  return {
    available: !0,
    type: t.type,
    deviceId: t.device_id,
    tokenSaved: t.token_saved,
    accessRequested: t.access_requested,
    accessGranted: t.access_granted
  };
}
class ze extends k {
  constructor({ postEvent: t, version: s, ...n }) {
    super(n, s, {
      auth: "web_app_biometry_request_auth",
      openSettings: "web_app_biometry_open_settings",
      requestAccess: "web_app_biometry_request_access",
      updateToken: "web_app_biometry_update_token"
    }), c(this, "postEvent"), c(this, "authPromise"), c(this, "accessPromise"), this.postEvent = t;
  }
  /**
   * Shows whether biometry is available.
   */
  get available() {
    return this.get("available");
  }
  /**
   * Shows whether permission to use biometrics has been granted.
   */
  get accessGranted() {
    return this.get("accessGranted");
  }
  /**
   * Shows whether if permission to use biometrics has been requested.
   */
  get accessRequested() {
    return this.get("accessRequested");
  }
  /**
   * Authenticates the user using biometrics.
   * @param options - method options.
   * @since 7.2
   * @returns Token from the local secure storage, if authentication was successful.
   */
  async authenticate({
    reason: t,
    ...s
  }) {
    return this.authPromise || (this.authPromise = w({
      ...s,
      method: "web_app_biometry_request_auth",
      event: "biometry_auth_requested",
      postEvent: this.postEvent,
      params: {
        // TODO: Check if reason is empty works fine.
        reason: (t || "").trim()
      }
    }).then(({ token: n }) => n).finally(() => this.authPromise = void 0)), this.authPromise;
  }
  /**
   * A unique device identifier that can be used to match the token to the device.
   */
  get deviceId() {
    return this.get("deviceId");
  }
  /**
   * Opens the biometric access settings for bots. Useful when you need to request biometrics
   * access to users who haven't granted it yet.
   *
   * _Note that this method can be called only in response to user interaction with the Mini App
   * interface (e.g. a click inside the Mini App or on the main button)_.
   * @since 7.2
   */
  openSettings() {
    this.postEvent("web_app_biometry_open_settings");
  }
  /**
   * Requests permission to use biometrics.
   * @since 7.2
   * @returns Promise with true, if access was granted.
   */
  requestAccess({ reason: t, ...s } = {}) {
    return this.accessPromise || (this.accessPromise = w({
      ...s,
      postEvent: this.postEvent,
      method: "web_app_biometry_request_access",
      event: "biometry_info_received",
      params: { reason: t || "" }
    }).then((n) => {
      const r = Qt(n);
      return this.set(r), r.accessGranted;
    }).finally(() => this.accessPromise = void 0)), this.accessPromise;
  }
  /**
   * The type of biometrics currently available on the device.
   */
  get biometryType() {
    return this.get("biometryType");
  }
  /**
   * Shows whether token was saved previously in the local secure storage.
   */
  get tokenSaved() {
    return this.get("tokenSaved");
  }
  /**
   * Updates the biometric token in a secure storage on the device.
   * @returns Promise with `true`, if token was updated.
   */
  async updateToken({ token: t, ...s } = {}) {
    return ["removed", "updated"].includes(
      (await w({
        ...s,
        postEvent: this.postEvent,
        method: "web_app_biometry_update_token",
        event: "biometry_token_updated",
        params: { token: t || "" }
      })).status
    );
  }
}
async function Ke(e) {
  return Qt(
    await w({
      ...e || {},
      method: "web_app_biometry_get_info",
      event: "biometry_info_received"
    })
  );
}
const Je = l(
  "biometryManager",
  async ({ postEvent: e, version: t, state: s }) => new ze({
    ...s || x("web_app_biometry_get_info", t) ? s || await Ke({ timeout: 1e3 }) : {
      available: !1,
      accessGranted: !1,
      accessRequested: !1,
      tokenSaved: !1,
      deviceId: ""
    },
    version: t,
    postEvent: e
  })
);
class dt extends ht {
  constructor() {
    super(...arguments), c(this, "on", this.state.on.bind(this.state)), c(this, "off", this.state.off.bind(this.state));
  }
}
class Fe extends dt {
  constructor(t, s) {
    super({ isConfirmationNeeded: t }), this.postEvent = s;
  }
  set isConfirmationNeeded(t) {
    this.set("isConfirmationNeeded", t), this.postEvent("web_app_setup_closing_behavior", { need_confirmation: t });
  }
  /**
   * True, if the confirmation dialog should be shown while the user is trying to close
   * the Mini App.
   */
  get isConfirmationNeeded() {
    return this.get("isConfirmationNeeded");
  }
  /**
   * Disables the confirmation dialog when closing the Mini App.
   */
  disableConfirmation() {
    this.isConfirmationNeeded = !1;
  }
  /**
   * Enables the confirmation dialog when closing the Mini App.
   */
  enableConfirmation() {
    this.isConfirmationNeeded = !0;
  }
}
const Qe = l(
  "closingBehavior",
  ({
    postEvent: e,
    state: t = { isConfirmationNeeded: !1 }
  }) => new Fe(t.isConfirmationNeeded, e)
);
class _t {
  constructor(t, s) {
    c(this, "supports"), this.supports = Mt(t, s);
  }
}
function Ye(e) {
  if (Array.isArray(e))
    return e;
  if (typeof e == "string")
    try {
      const t = JSON.parse(e);
      if (Array.isArray(t))
        return t;
    } catch {
    }
  throw T();
}
class Ze extends G {
  constructor(t, s, n) {
    super(Ye, s, n), c(this, "itemParser"), this.itemParser = typeof t == "function" ? t : t.parse.bind(t);
  }
  /**
   * Attempts to parse passed value
   * @param value - value to parse.
   * @throws {SDKError} ERR_PARSE
   * @see ERR_PARSE
   */
  parse(t) {
    const s = super.parse(t);
    return s === void 0 ? s : s.map(this.itemParser);
  }
  of(t) {
    return this.itemParser = typeof t == "function" ? t : t.parse.bind(t), this;
  }
}
function Xe(e) {
  return new Ze((t) => t, !1, e);
}
function yt(e, t) {
  return Object.fromEntries(e.map((s) => [s, t]));
}
class ts extends _t {
  constructor(t, s, n) {
    super(t, {
      delete: "web_app_invoke_custom_method",
      get: "web_app_invoke_custom_method",
      getKeys: "web_app_invoke_custom_method",
      set: "web_app_invoke_custom_method"
    }), this.createRequestId = s, this.postEvent = n;
  }
  /**
   * Deletes specified key or keys from the cloud storage.
   * @param keyOrKeys - key or keys to delete.
   * @param options - request execution options.
   */
  async delete(t, s = {}) {
    const n = Array.isArray(t) ? t : [t];
    n.length && await V(
      "deleteStorageValues",
      { keys: n },
      this.createRequestId(),
      { ...s, postEvent: this.postEvent }
    );
  }
  /**
   * Returns list of all keys presented in the cloud storage.
   * @param options - request execution options.
   */
  async getKeys(t = {}) {
    return Xe().of(u()).parse(
      await V(
        "getStorageKeys",
        {},
        this.createRequestId(),
        { ...t, postEvent: this.postEvent }
      )
    );
  }
  async get(t, s = {}) {
    const n = Array.isArray(t) ? t : [t];
    if (!n.length)
      return yt(n, "");
    const r = await V(
      "getStorageValues",
      { keys: n },
      this.createRequestId(),
      { ...s, postEvent: this.postEvent }
    ), i = v(yt(n, u()), "CloudStorageData").parse(r);
    return Array.isArray(t) ? i : i[t];
  }
  /**
   * Saves specified value by key.
   * @param key - storage key.
   * @param value - storage value.
   * @param options - request execution options.
   */
  async set(t, s, n = {}) {
    await V(
      "saveStorageValue",
      { key: t, value: s },
      this.createRequestId(),
      { ...n, postEvent: this.postEvent }
    );
  }
}
const es = l(
  ({ createRequestId: e, postEvent: t, version: s }) => new ts(s, e, t)
);
class ss extends _t {
  constructor(t, s) {
    super(t, {
      impactOccurred: "web_app_trigger_haptic_feedback",
      notificationOccurred: "web_app_trigger_haptic_feedback",
      selectionChanged: "web_app_trigger_haptic_feedback"
    }), this.postEvent = s;
  }
  /**
   * A method tells that an impact occurred. The Telegram app may play the
   * appropriate haptics based on style value passed.
   * @param style - impact style.
   */
  impactOccurred(t) {
    this.postEvent("web_app_trigger_haptic_feedback", {
      type: "impact",
      impact_style: t
    });
  }
  /**
   * A method tells that a task or action has succeeded, failed, or produced
   * a warning. The Telegram app may play the appropriate haptics based on
   * type value passed.
   * @param type - notification type.
   */
  notificationOccurred(t) {
    this.postEvent("web_app_trigger_haptic_feedback", {
      type: "notification",
      notification_type: t
    });
  }
  /**
   * A method tells that the user has changed a selection. The Telegram app
   * may play the appropriate haptics.
   *
   * Do not use this feedback when the user makes or confirms a selection;
   * use it only when the selection changes.
   */
  selectionChanged() {
    this.postEvent("web_app_trigger_haptic_feedback", { type: "selection_change" });
  }
}
const ns = l(
  ({ version: e, postEvent: t }) => new ss(e, t)
);
class rs {
  constructor(t) {
    this.initData = t;
  }
  /**
   * @see InitDataParsed.authDate
   */
  get authDate() {
    return this.initData.authDate;
  }
  /**
   * @see InitDataParsed.canSendAfter
   */
  get canSendAfter() {
    return this.initData.canSendAfter;
  }
  /**
   * Date after which it is allowed to call
   * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.
   */
  get canSendAfterDate() {
    const { canSendAfter: t } = this;
    return t ? new Date(this.authDate.getTime() + t * 1e3) : void 0;
  }
  /**
   * @see InitDataParsed.chat
   */
  get chat() {
    return this.initData.chat;
  }
  /**
   * @see InitDataParsed.chatType
   */
  get chatType() {
    return this.initData.chatType;
  }
  /**
   * @see InitDataParsed.chatInstance
   */
  get chatInstance() {
    return this.initData.chatInstance;
  }
  /**
   * @see InitDataParsed.hash
   */
  get hash() {
    return this.initData.hash;
  }
  /**
   * @see InitDataParsed.queryId
   */
  get queryId() {
    return this.initData.queryId;
  }
  /**
   * @see InitDataParsed.receiver
   */
  get receiver() {
    return this.initData.receiver;
  }
  /**
   * @see InitDataParsed.startParam
   */
  get startParam() {
    return this.initData.startParam;
  }
  /**
   * @see InitDataParsed.user
   */
  get user() {
    return this.initData.user;
  }
}
const is = l(
  ({ initData: e }) => e ? new rs(e) : void 0
);
function En(e) {
  return $t().parse(e);
}
class os extends k {
  constructor(t, s, n) {
    super({ isOpened: t }, s, { open: "web_app_open_invoice" }), this.postEvent = n;
  }
  set isOpened(t) {
    this.set("isOpened", t);
  }
  /**
   * True if invoice is currently opened.
   */
  get isOpened() {
    return this.get("isOpened");
  }
  async open(t, s) {
    if (this.isOpened)
      throw new Error("Invoice is already opened");
    let n;
    if (!s)
      n = t;
    else {
      const { hostname: r, pathname: i } = new URL(t, window.location.href);
      if (r !== "t.me")
        throw new Error(`Incorrect hostname: ${r}`);
      const o = i.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
      if (!o)
        throw new Error('Link pathname has incorrect format. Expected to receive "/invoice/{slug}" or "/${slug}"');
      [, , n] = o;
    }
    this.isOpened = !0;
    try {
      return (await w({
        method: "web_app_open_invoice",
        event: "invoice_closed",
        params: { slug: n },
        postEvent: this.postEvent,
        capture(r) {
          return n === r.slug;
        }
      })).status;
    } finally {
      this.isOpened = !1;
    }
  }
}
const as = l(
  ({ version: e, postEvent: t }) => new os(!1, e, t)
);
class cs extends ht {
  constructor({ postEvent: t, ...s }) {
    super(s), c(this, "postEvent"), c(this, "on", (n, r) => n === "click" ? y("main_button_pressed", r) : this.state.on(n, r)), c(this, "off", (n, r) => n === "click" ? z("main_button_pressed", r) : this.state.off(n, r)), this.postEvent = t;
  }
  /**
   * The MainButton background color.
   */
  get bgColor() {
    return this.get("bgColor");
  }
  /**
   * Sends current local state to the Telegram application.
   */
  commit() {
    this.text !== "" && this.postEvent("web_app_setup_main_button", {
      is_visible: this.isVisible,
      is_active: this.isEnabled,
      is_progress_visible: this.isLoaderVisible,
      text: this.text,
      color: this.bgColor,
      text_color: this.textColor
    });
  }
  /**
   * Disables the MainButton.
   * @see Does not work on Android: https://github.com/Telegram-Mini-Apps/issues/issues/1
   */
  disable() {
    return this.isEnabled = !1, this;
  }
  /**
   * Enables the MainButton.
   */
  enable() {
    return this.isEnabled = !0, this;
  }
  /**
   * Hides the MainButton.
   */
  hide() {
    return this.isVisible = !1, this;
  }
  /**
   * Hides the MainButton loading indicator.
   */
  hideLoader() {
    return this.isLoaderVisible = !1, this;
  }
  set isEnabled(t) {
    this.setParams({ isEnabled: t });
  }
  /**
   * True if the MainButton is enabled.
   */
  get isEnabled() {
    return this.get("isEnabled");
  }
  set isLoaderVisible(t) {
    this.setParams({ isLoaderVisible: t });
  }
  /**
   * True if the MainButton loader is visible.
   */
  get isLoaderVisible() {
    return this.get("isLoaderVisible");
  }
  set isVisible(t) {
    this.setParams({ isVisible: t });
  }
  /**
   * True if the MainButton is visible.
   */
  get isVisible() {
    return this.get("isVisible");
  }
  /**
   * Shows the MainButton.
   *
   * Note that opening the Mini App from the attachment menu hides the main button until the
   * user interacts with the Mini App interface.
   */
  show() {
    return this.isVisible = !0, this;
  }
  /**
   * Shows a loading indicator on the Main Button.
   */
  showLoader() {
    return this.isLoaderVisible = !0, this;
  }
  /**
   * Sets a new MainButton text. Minimal length for the text is 1 symbol, and maximum is 64 symbols.
   * @param text - a new text.
   */
  setText(t) {
    return this.setParams({ text: t });
  }
  /**
   * Sets a new Main Button text color.
   * @param textColor - new text color.
   */
  setTextColor(t) {
    return this.setParams({ textColor: t });
  }
  /**
   * Updates current Main Button color.
   * @param bgColor - color to set.
   */
  setBgColor(t) {
    return this.setParams({ bgColor: t });
  }
  /**
   * Allows setting multiple Main Button parameters.
   * @param params - Main Button parameters.
   */
  setParams(t) {
    return this.set(t), this.commit(), this;
  }
  /**
   * The MainButton text.
   */
  get text() {
    return this.get("text");
  }
  /**
   * The MainButton text color.
   */
  get textColor() {
    return this.get("textColor");
  }
}
const hs = l(
  "mainButton",
  ({
    postEvent: e,
    themeParams: t,
    state: s = {
      isVisible: !1,
      isEnabled: !1,
      text: "",
      isLoaderVisible: !1,
      textColor: t.buttonTextColor || "#ffffff",
      bgColor: t.buttonColor || "#000000"
    }
  }) => new cs({ ...s, postEvent: e })
);
function ps() {
  return ut({
    contact: v({
      userId: {
        type: R(),
        from: "user_id"
      },
      phoneNumber: {
        type: u(),
        from: "phone_number"
      },
      firstName: {
        type: u(),
        from: "first_name"
      },
      lastName: {
        type: u().optional(),
        from: "last_name"
      }
    }),
    authDate: {
      type: Lt(),
      from: "auth_date"
    },
    hash: u()
  }, "RequestedContact");
}
function Yt(e, t) {
  return (s) => {
    const [n, r] = t[s];
    return x(n, r, e);
  };
}
function us(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
class ls extends k {
  constructor({ postEvent: t, createRequestId: s, version: n, botInline: r, ...i }) {
    super(i, n, {
      requestPhoneAccess: "web_app_request_phone",
      requestWriteAccess: "web_app_request_write_access",
      switchInlineQuery: "web_app_switch_inline_query",
      setHeaderColor: "web_app_set_header_color",
      setBackgroundColor: "web_app_set_background_color"
    }), c(this, "botInline"), c(this, "postEvent"), c(this, "createRequestId"), c(this, "requestPhoneAccessPromise"), c(this, "requestWriteAccessPromise"), c(this, "supportsParam"), this.createRequestId = s, this.postEvent = t, this.botInline = r;
    const o = this.supports.bind(this);
    this.supports = (a) => o(a) ? a !== "switchInlineQuery" || r : !1, this.supportsParam = Yt(n, {
      "setHeaderColor.color": ["web_app_set_header_color", "color"],
      "close.returnBack": ["web_app_close", "return_back"]
    });
  }
  /**
   * Attempts to get requested contact.
   * @param timeout - request timeout.
   */
  async getRequestedContact({
    timeout: t = 1e4
  } = {}) {
    return ps().parse(
      await V(
        "getRequestedContact",
        {},
        this.createRequestId(),
        { postEvent: this.postEvent, timeout: t }
      )
    );
  }
  /**
   * The Mini App background color.
   * @example "#ffaabb"
   */
  get bgColor() {
    return this.get("bgColor");
  }
  /**
   * Closes the Mini App.
   * @param returnBack - should the application be wrapped into the bottom bar.
   */
  close(t) {
    this.postEvent("web_app_close", this.supportsParam("close.returnBack") ? { return_back: t } : {});
  }
  /**
   * The Mini App header color.
   * @example "#ffaabb"
   * @example "bg_color"
   */
  get headerColor() {
    return this.get("headerColor");
  }
  /**
   * True if the Mini App is currently launched in bot inline mode.
   */
  get isBotInline() {
    return this.botInline;
  }
  /**
   * True if the current Mini App background color is recognized as dark.
   */
  get isDark() {
    return Bt(this.bgColor);
  }
  /**
   * Informs the Telegram app that the Mini App is ready to be displayed.
   *
   * It is recommended to call this method as early as possible, as soon as all essential
   * interface elements loaded. Once this method called, the loading placeholder is hidden
   * and the Mini App shown.
   *
   * If the method not called, the placeholder will be hidden only when the page fully loaded.
   */
  ready() {
    this.postEvent("web_app_ready");
  }
  /**
   * Requests current user contact information. In contrary to requestPhoneAccess, this method
   * returns promise with contact information that rejects in case, user denied access, or request
   * failed.
   * @param options - additional options.
   */
  async requestContact({ timeout: t = 5e3 } = {}) {
    try {
      return await this.getRequestedContact();
    } catch {
    }
    if (await this.requestPhoneAccess() !== "sent")
      throw new Error("Access denied.");
    const s = Date.now() + t;
    let n = 50;
    return Nt(async () => {
      for (; Date.now() < s; ) {
        try {
          return await this.getRequestedContact();
        } catch {
        }
        await us(n), n += 50;
      }
      throw Vt(t);
    }, t);
  }
  /**
   * Requests current user phone access. Method returns promise, which resolves
   * status of the request. In case, user accepted the request, Mini App bot will receive
   * the according notification.
   *
   * To obtain the retrieved information instead, utilize the `requestContact` method.
   * @param options - additional options.
   * @see requestContact
   */
  async requestPhoneAccess(t = {}) {
    return this.requestPhoneAccessPromise || (this.requestPhoneAccessPromise = w({
      ...t,
      method: "web_app_request_phone",
      event: "phone_requested",
      postEvent: this.postEvent
    }).then(({ status: s }) => s).finally(() => this.requestPhoneAccessPromise = void 0)), this.requestPhoneAccessPromise;
  }
  /**
   * Requests write message access to current user.
   * @param options - additional options.
   */
  async requestWriteAccess(t = {}) {
    return this.requestWriteAccessPromise || (this.requestWriteAccessPromise = w({
      ...t,
      method: "web_app_request_write_access",
      event: "write_access_requested",
      postEvent: this.postEvent
    }).then(({ status: s }) => s).finally(() => this.requestWriteAccessPromise = void 0)), this.requestWriteAccessPromise;
  }
  /**
   * A method used to send data to the bot. When this method called, a service message sent to
   * the bot containing the data of the length up to 4096 bytes, and the Mini App closed. See the
   * field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).
   *
   * This method is only available for Mini Apps launched via a Keyboard button.
   * @param data - data to send to bot.
   * @throws {Error} data has incorrect size.
   */
  sendData(t) {
    const { size: s } = new Blob([t]);
    if (!s || s > 4096)
      throw new Error(`Passed data has incorrect size: ${s}`);
    this.postEvent("web_app_data_send", { data: t });
  }
  /**
   * Updates current Mini App header color.
   *
   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/9
   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/8
   * @param color - color key or RGB color.
   */
  setHeaderColor(t) {
    this.postEvent("web_app_set_header_color", ct(t) ? { color: t } : { color_key: t }), this.set("headerColor", t);
  }
  /**
   * Updates current Mini App background color.
   *
   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/9
   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/8
   * @param color - RGB color.
   */
  setBgColor(t) {
    this.postEvent("web_app_set_background_color", { color: t }), this.set("bgColor", t);
  }
  /**
   * Inserts the bot's username and the specified inline query in the current chat's input field.
   * Query may be empty, in which case only the bot's username will be inserted. The client prompts
   * the user to choose a specific chat, then opens that chat and inserts the bot's username and
   * the specified inline query in the input field.
   * @param text - text which should be inserted in the input after the current bot name. Max
   * length is 256 symbols.
   * @param chatTypes - List of chat types which could be chosen to send the message. Could be
   * empty list.
   */
  switchInlineQuery(t, s = []) {
    if (!this.supports("switchInlineQuery") && !this.isBotInline)
      throw new Error("Method is unsupported because Mini App should be launched in inline mode.");
    this.postEvent("web_app_switch_inline_query", { query: t, chat_types: s });
  }
}
const ds = l(
  "miniApp",
  ({
    themeParams: e,
    botInline: t = !1,
    state: s = {
      bgColor: e.bgColor || "#ffffff",
      headerColor: e.headerBgColor || "#000000"
    },
    ...n
  }) => new ls({ ...n, ...s, botInline: t })
);
function _s(e) {
  const t = e.message.trim(), s = (e.title || "").trim(), n = e.buttons || [];
  let r;
  if (s.length > 64)
    throw new Error(`Title has incorrect size: ${s.length}`);
  if (!t.length || t.length > 256)
    throw new Error(`Message has incorrect size: ${t.length}`);
  if (n.length > 3)
    throw new Error(`Buttons have incorrect size: ${n.length}`);
  return n.length ? r = n.map((i) => {
    const { id: o = "" } = i;
    if (o.length > 64)
      throw new Error(`Button ID has incorrect size: ${o}`);
    if (!i.type || i.type === "default" || i.type === "destructive") {
      const a = i.text.trim();
      if (!a.length || a.length > 64) {
        const h = i.type || "default";
        throw new Error(`Button text with type "${h}" has incorrect size: ${i.text.length}`);
      }
      return { ...i, text: a, id: o };
    }
    return { ...i, id: o };
  }) : r = [{ type: "close", id: "" }], { title: s, message: t, buttons: r };
}
class ws extends k {
  constructor(t, s, n) {
    super({ isOpened: t }, s, { open: "web_app_open_popup" }), this.postEvent = n;
  }
  set isOpened(t) {
    this.set("isOpened", t);
  }
  /**
   * True if the Popup is opened.
   */
  get isOpened() {
    return this.get("isOpened");
  }
  /**
   * A method that shows a native popup described by the `params` argument.
   * Promise will be resolved when popup is closed. Resolved value will have
   * an identifier of pressed button.
   *
   * In case, user clicked outside the popup or clicked top right popup close
   * button, null will be returned.
   *
   * @param options - popup parameters.
   * @throws {Error} Popup is already opened.
   */
  async open(t) {
    if (this.isOpened)
      throw new Error("Popup is already opened.");
    this.isOpened = !0;
    try {
      const { button_id: s = null } = await w({
        event: "popup_closed",
        method: "web_app_open_popup",
        postEvent: this.postEvent,
        params: _s(t)
      });
      return s;
    } finally {
      this.isOpened = !1;
    }
  }
}
const gs = l(
  ({ postEvent: e, version: t }) => new ws(!1, t, e)
);
class fs extends k {
  constructor(t, s, n) {
    super({ isOpened: t }, s, {
      close: "web_app_close_scan_qr_popup",
      open: "web_app_open_scan_qr_popup"
    }), this.postEvent = n;
  }
  /**
   * Closes the scanner.
   */
  close() {
    this.postEvent("web_app_close_scan_qr_popup"), this.isOpened = !1;
  }
  set isOpened(t) {
    this.set("isOpened", t);
  }
  /**
   * Returns true if the scanner is currently opened.
   */
  get isOpened() {
    return this.get("isOpened");
  }
  async open(t) {
    if (this.isOpened)
      throw new Error("The scanner is already opened");
    const { text: s, capture: n } = (typeof t == "string" ? { text: t } : t) || {};
    this.isOpened = !0;
    try {
      const r = (await w({
        method: "web_app_open_scan_qr_popup",
        event: ["qr_text_received", "scan_qr_popup_closed"],
        postEvent: this.postEvent,
        params: { text: s },
        capture(i) {
          return i.event === "scan_qr_popup_closed" || !n || n(i.payload);
        }
      }) || {}).data || null;
      return r && this.close(), r;
    } finally {
      this.isOpened = !1;
    }
  }
  // TODO: Streaming mode, allowing to scan several QRs until closed.
}
const bs = l(
  ({ version: e, postEvent: t }) => new fs(!1, e, t)
);
class ms extends pt {
  constructor(t, s, n) {
    super({ isVisible: t }, s, {
      show: "web_app_setup_settings_button",
      hide: "web_app_setup_settings_button"
    }), c(this, "on", (r, i) => r === "click" ? y("settings_button_pressed", i) : this.state.on(r, i)), c(this, "off", (r, i) => r === "click" ? z("settings_button_pressed", i) : this.state.off(r, i)), this.postEvent = n;
  }
  set isVisible(t) {
    this.set("isVisible", t), this.postEvent("web_app_setup_settings_button", { is_visible: t });
  }
  /**
   * True if the SettingsButton is visible.
   */
  get isVisible() {
    return this.get("isVisible");
  }
  /**
   * Hides the SettingsButton.
   */
  hide() {
    this.isVisible = !1;
  }
  /**
   * Shows the SettingsButton.
   */
  show() {
    this.isVisible = !0;
  }
}
const vs = l(
  "settingsButton",
  ({
    version: e,
    postEvent: t,
    state: s = { isVisible: !1 }
  }) => new ms(s.isVisible, e, t)
);
class ys extends k {
  constructor(t, s, n) {
    super({ isVerticalSwipeEnabled: t }, s, {
      disableVerticalSwipe: "web_app_setup_swipe_behavior",
      enableVerticalSwipe: "web_app_setup_swipe_behavior"
    }), this.postEvent = n;
  }
  set isVerticalSwipeEnabled(t) {
    this.set("isVerticalSwipeEnabled", t), this.postEvent("web_app_setup_swipe_behavior", { allow_vertical_swipe: t });
  }
  /**
   * True, if the vertical swipe enabled.
   */
  get isVerticalSwipeEnabled() {
    return this.get("isVerticalSwipeEnabled");
  }
  /**
   * Disables the vertical swipe.
   */
  disableVerticalSwipe() {
    this.isVerticalSwipeEnabled = !1;
  }
  /**
   * Enables the vertical swipe.
   */
  enableVerticalSwipe() {
    this.isVerticalSwipeEnabled = !0;
  }
}
const Es = l(
  "swipeBehavior",
  ({
    postEvent: e,
    state: t = { isVerticalSwipeEnabled: !0 },
    version: s
  }) => new ys(t.isVerticalSwipeEnabled, s, e)
);
function Zt(e) {
  return Ht().parse(e);
}
class Ps extends dt {
  /**
   * @since v6.10
   */
  get accentTextColor() {
    return this.get("accentTextColor");
  }
  get bgColor() {
    return this.get("bgColor");
  }
  get buttonColor() {
    return this.get("buttonColor");
  }
  get buttonTextColor() {
    return this.get("buttonTextColor");
  }
  get destructiveTextColor() {
    return this.get("destructiveTextColor");
  }
  /**
   * Returns the copy of the internal state of the current component instance.
   */
  getState() {
    return this.clone();
  }
  /**
   * @since v6.10
   */
  get headerBgColor() {
    return this.get("headerBgColor");
  }
  get hintColor() {
    return this.get("hintColor");
  }
  /**
   * @returns True in case, current color scheme is recognized as dark. This
   * value is calculated according to theme bg color.
   */
  get isDark() {
    return !this.bgColor || Bt(this.bgColor);
  }
  get linkColor() {
    return this.get("linkColor");
  }
  get secondaryBgColor() {
    return this.get("secondaryBgColor");
  }
  /**
   * @since v6.10
   */
  get sectionBgColor() {
    return this.get("sectionBgColor");
  }
  /**
   * @since v6.10
   */
  get sectionHeaderTextColor() {
    return this.get("sectionHeaderTextColor");
  }
  /**
   * @since v7.6
   */
  get sectionSeparatorColor() {
    return this.get("sectionHeaderTextColor");
  }
  /**
   * Starts listening to the external theme changes and applies them.
   * @returns Function to stop listening.
   */
  listen() {
    return y("theme_changed", (t) => {
      this.set(Zt(t.theme_params));
    });
  }
  /**
   * @since v6.10
   */
  get subtitleTextColor() {
    return this.get("subtitleTextColor");
  }
  get textColor() {
    return this.get("textColor");
  }
}
const Ss = l(
  "themeParams",
  ({ themeParams: e, state: t = e, addCleanup: s }) => {
    const n = new Ps(t);
    return s(n.listen()), n;
  }
);
function Pn(e = {}) {
  return w({
    ...e,
    method: "web_app_request_theme",
    event: "theme_changed"
  }).then(Zt);
}
function M(e, t) {
  return e.startsWith(t) ? e : `${t}${e}`;
}
function L(e) {
  return new URL(
    typeof e == "string" ? e : `${e.pathname || ""}${M(e.search || "", "?")}${M(e.hash || "", "#")}`,
    "http://a"
  );
}
class Rs extends _t {
  constructor(t, s, n) {
    super(t, { readTextFromClipboard: "web_app_read_text_from_clipboard" }), c(this, "supportsParam"), this.version = t, this.createRequestId = s, this.postEvent = n, this.supportsParam = Yt(t, {
      "openLink.tryInstantView": ["web_app_open_link", "try_instant_view"]
    });
  }
  openLink(t, s) {
    const n = L(t).toString();
    if (!x("web_app_open_link", this.version)) {
      window.open(n, "_blank");
      return;
    }
    const r = typeof s == "boolean" ? { tryInstantView: s } : s || {};
    this.postEvent("web_app_open_link", {
      url: n,
      try_browser: r.tryBrowser,
      try_instant_view: r.tryInstantView
    });
  }
  /**
   * Opens a Telegram link inside Telegram app. The Mini App will be closed. It expects passing
   * link in full format, with hostname "t.me".
   * @param url - URL to be opened.
   * @throws {Error} URL has not allowed hostname.
   */
  openTelegramLink(t) {
    const { hostname: s, pathname: n, search: r } = new URL(t, "https://t.me");
    if (s !== "t.me")
      throw new Error(`URL has not allowed hostname: ${s}. Only "t.me" is allowed`);
    if (!x("web_app_open_tg_link", this.version)) {
      window.location.href = t;
      return;
    }
    this.postEvent("web_app_open_tg_link", { path_full: n + r });
  }
  /**
   * Reads text from clipboard and returns string or null. null is returned
   * in cases:
   * - Value in clipboard is not text
   * - Access to clipboard is not allowed
   */
  async readTextFromClipboard() {
    const t = this.createRequestId(), {
      data: s = null
    } = await w({
      method: "web_app_read_text_from_clipboard",
      event: "clipboard_text_received",
      postEvent: this.postEvent,
      params: { req_id: t },
      capture: qt(t)
    });
    return s;
  }
  /**
   * Shares specified URL with the passed to the chats, selected by user. After being called,
   * it closes the mini application.
   *
   * This method uses Telegram's Share Links.
   * @param url - URL to share.
   * @param text - text to append after the URL.
   * @see https://core.telegram.org/api/links#share-links
   * @see https://core.telegram.org/widgets/share#custom-buttons
   */
  shareURL(t, s) {
    this.openTelegramLink(
      "https://t.me/share/url?" + new URLSearchParams({ url: t, text: s || "" }).toString().replace(/\+/g, "%20")
    );
  }
}
const xs = l(
  ({ version: e, postEvent: t, createRequestId: s }) => new Rs(e, s, t)
);
async function Xt(e = {}) {
  const {
    is_expanded: t,
    is_state_stable: s,
    ...n
  } = await w({
    ...e,
    method: "web_app_request_viewport",
    event: "viewport_changed"
  });
  return { ...n, isExpanded: t, isStateStable: s };
}
function q(e) {
  return e < 0 ? 0 : e;
}
class Cs extends dt {
  constructor({ postEvent: t, stableHeight: s, height: n, width: r, isExpanded: i }) {
    super({
      height: q(n),
      isExpanded: i,
      stableHeight: q(s),
      width: q(r)
    }), c(this, "postEvent"), this.postEvent = t;
  }
  /**
   * Requests viewport information from the Telegram application and updates current Viewport
   * instance.
   * @param options - options to request fresh data.
   */
  async sync(t) {
    const { isStateStable: s, ...n } = await Xt(t);
    this.set({
      ...n,
      stableHeight: s ? n.height : this.get("stableHeight")
    });
  }
  /**
   * The current height of the **visible area** of the Mini App.
   *
   * The application can display just the top part of the Mini App, with its lower part remaining
   * outside the screen area. From this position, the user can "pull" the Mini App to its
   * maximum height, while the bot can do the same by calling `expand` method. As the position of
   * the Mini App changes, the current height value of the visible area will be updated  in real
   * time.
   *
   * Please note that the refresh rate of this value is not sufficient to smoothly follow the
   * lower border of the window. It should not be used to pin interface elements to the bottom
   * of the visible area. It's more appropriate to use the value of the `stableHeight`
   * field for this purpose.
   *
   * @see stableHeight
   */
  get height() {
    return this.get("height");
  }
  /**
   * The height of the visible area of the Mini App in its last stable state.
   *
   * The application can display just the top part of the Mini App, with its lower part remaining
   * outside the screen area. From this position, the user can "pull" the Mini App to its
   * maximum height, while the application can do the same by calling `expand` method.
   *
   * Unlike the value of `height`, the value of `stableHeight` does not change as the position
   * of the Mini App changes with user gestures or during animations. The value of `stableHeight`
   * will be updated after all gestures and animations are completed and
   * the Mini App reaches its final size.
   *
   * @see height
   */
  get stableHeight() {
    return this.get("stableHeight");
  }
  /**
   * Starts listening to viewport changes and applies them.
   * @returns Function to stop listening.
   */
  listen() {
    return y("viewport_changed", (t) => {
      const {
        height: s,
        width: n,
        is_expanded: r,
        is_state_stable: i
      } = t, o = q(s);
      this.set({
        height: o,
        isExpanded: r,
        width: q(n),
        ...i ? { stableHeight: o } : {}
      });
    });
  }
  /**
   * True if the Mini App is expanded to the maximum available height. Otherwise, if
   * the Mini App occupies part of the screen and can be expanded to the full height using
   * `expand` method.
   * @see expand
   */
  get isExpanded() {
    return this.get("isExpanded");
  }
  /**
   * Current visible area width.
   */
  get width() {
    return this.get("width");
  }
  /**
   * A method that expands the Mini App to the maximum available height. To find out if the Mini
   * App is expanded to the maximum height, refer to the value of the `isExpanded`.
   * @see isExpanded
   */
  expand() {
    this.postEvent("web_app_expand"), this.set("isExpanded", !0);
  }
  /**
   * True if the current viewport height is stable and is not going to change in the next moment.
   */
  get isStable() {
    return this.stableHeight === this.height;
  }
}
const Ts = l(
  "viewport",
  async ({ state: e, platform: t, postEvent: s, addCleanup: n }) => {
    let r = !1, i = 0, o = 0, a = 0;
    if (e)
      r = e.isExpanded, i = e.height, o = e.width, a = e.stableHeight;
    else if (["macos", "tdesktop", "unigram", "webk", "weba", "web"].includes(t))
      r = !0, i = window.innerHeight, o = window.innerWidth, a = window.innerHeight;
    else {
      const p = await Xt({ timeout: 1e3, postEvent: s });
      r = p.isExpanded, i = p.height, o = p.width, a = p.isStateStable ? i : 0;
    }
    const h = new Cs({
      postEvent: s,
      height: i,
      width: o,
      stableHeight: a,
      isExpanded: r
    });
    return n(h.listen()), h;
  }
);
function P(e, t) {
  document.documentElement.style.setProperty(e, t);
}
function Sn(e, t, s) {
  s || (s = (a) => `--tg-${a}-color`);
  const n = s("header"), r = s("bg"), i = () => {
    const { headerColor: a } = e;
    if (ct(a))
      P(n, a);
    else {
      const { bgColor: h, secondaryBgColor: p } = t;
      a === "bg_color" && h ? P(n, h) : a === "secondary_bg_color" && p && P(n, p);
    }
    P(r, e.bgColor);
  }, o = [
    t.on("change", i),
    e.on("change", i)
  ];
  return i(), () => o.forEach((a) => a());
}
function Rn(e, t) {
  t || (t = (n) => `--tg-theme-${n.replace(/[A-Z]/g, (r) => `-${r.toLowerCase()}`)}`);
  const s = () => {
    Object.entries(e.getState()).forEach(([n, r]) => {
      r && P(t(n), r);
    });
  };
  return s(), e.on("change", s);
}
function xn(e, t) {
  t || (t = (p) => `--tg-viewport-${p}`);
  const [
    s,
    n,
    r
  ] = ["height", "width", "stable-height"].map((p) => t(p)), i = () => P(s, `${e.height}px`), o = () => P(n, `${e.width}px`), a = () => P(r, `${e.stableHeight}px`), h = [
    e.on("change:height", i),
    e.on("change:width", o),
    e.on("change:stableHeight", a)
  ];
  return i(), o(), a(), () => h.forEach((p) => p());
}
function As(e = !0) {
  const t = [
    y("reload_iframe", () => {
      B("iframe_will_reload"), window.location.reload();
    })
  ], s = () => t.forEach((n) => n());
  if (e) {
    const n = document.createElement("style");
    n.id = "telegram-custom-styles", document.head.appendChild(n), t.push(
      y("set_custom_style", (r) => {
        n.innerHTML = r;
      }),
      () => document.head.removeChild(n)
    );
  }
  return B("iframe_ready", { reload_supported: !0 }), s;
}
function ks() {
  return typeof window > "u";
}
async function Cn() {
  if (It(window))
    return !0;
  try {
    return await w({ method: "web_app_request_theme", event: "theme_changed", timeout: 100 }), !0;
  } catch {
    return !1;
  }
}
function Tn(e) {
  const t = typeof e == "string" ? lt(e) : e;
  Jt(t);
  function s(r) {
    if (typeof r == "string")
      try {
        const { eventType: i } = At(r);
        i === "web_app_request_theme" && et("theme_changed", {
          theme_params: JSON.parse(Kt(t.themeParams))
        }), i === "web_app_request_viewport" && et("viewport_changed", {
          width: window.innerWidth,
          height: window.innerHeight,
          is_state_stable: !0,
          is_expanded: !0
        });
      } catch {
      }
  }
  if (at()) {
    const r = window.parent.postMessage.bind(window.parent);
    window.parent.postMessage = (i) => {
      s(i), r(i);
    };
    return;
  }
  if (kt(window)) {
    const r = window.external.notify.bind(window.external);
    window.external.notify = (i) => {
      s(i), r(i);
    };
    return;
  }
  const n = window.TelegramWebviewProxy;
  window.TelegramWebviewProxy = {
    ...n || {},
    postEvent(...r) {
      s(JSON.stringify({ eventType: r[0], eventData: r[1] })), n && n.postEvent(...r);
    }
  };
}
function Is(e) {
  return e instanceof W;
}
function An(e, t) {
  return Is(e) && e.type === t;
}
function J(e, t) {
  let s, n, r;
  return typeof e == "string" ? s = e : (s = e.pathname === void 0 ? t : e.pathname, n = e.params, r = e.id), Object.freeze({
    id: r || (Math.random() * 2 ** 14 | 0).toString(16),
    pathname: s,
    params: n
  });
}
class Os {
  constructor(t, s, n = B) {
    if (c(this, "history"), c(this, "ee", new D()), c(this, "attached", !1), c(this, "back", () => this.go(-1)), c(this, "on", this.ee.on.bind(this.ee)), c(this, "off", this.ee.off.bind(this.ee)), this._index = s, this.postEvent = n, t.length === 0)
      throw b(me, "History should not be empty.");
    if (s < 0 || s >= t.length)
      throw b(
        ve,
        "Index should not be zero and higher or equal than history size."
      );
    this.history = t.map((r) => J(r, ""));
  }
  /**
   * Allows this navigator to control the `BackButton` visibility state. It also tracks the
   * `BackButton` clicks and calls the `back` method.
   */
  attach() {
    this.attached || (this.attached = !0, this.sync(), y("back_button_pressed", this.back));
  }
  /**
   * Currently active history item.
   */
  get current() {
    return this.history[this.index];
  }
  /**
   * Prevents current navigator from controlling the BackButton visibility state.
   */
  detach() {
    this.attached = !1, z("back_button_pressed", this.back);
  }
  /**
   * Goes to the next history item.
   */
  forward() {
    this.go(1);
  }
  /**
   * Changes currently active history item index by the specified delta. This method doesn't
   * change index in case, the updated index points to the non-existing history item. This behavior
   * is preserved until the `fit` argument is specified.
   * @param delta - index delta.
   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.
   */
  go(t, s) {
    const n = this.index + t, r = Math.min(
      Math.max(0, n),
      this.history.length - 1
    );
    (n === r || s) && this.replaceAndMove(r, this.history[r]);
  }
  /**
   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.
   *
   * If "fit" option was specified and index is out of bounds, it will be cut to the nearest
   * bound.
   * @param index - target index.
   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.
   */
  goTo(t, s) {
    this.go(t - this.index, s);
  }
  /**
   * True if navigator has items before the current item.
   */
  get hasPrev() {
    return this.index > 0;
  }
  /**
   * True if navigator has items after the current item.
   */
  get hasNext() {
    return this.index !== this.history.length - 1;
  }
  /**
   * Currently active history item index.
   */
  get index() {
    return this._index;
  }
  /**
   * Adds a new history item removing all after the current one.
   * @param item - item to add.
   */
  push(t) {
    this.hasNext && this.history.splice(this.index + 1), this.replaceAndMove(this.index + 1, J(t, this.current.pathname));
  }
  /**
   * Replaces the current history item.
   * @param item - item to replace the current item with.
   */
  replace(t) {
    this.replaceAndMove(this.index, J(t, this.current.pathname));
  }
  /**
   * Sets history item by the specified index.
   * @param index - history item index to replace.
   * @param historyItem - history item to set.
   */
  replaceAndMove(t, s) {
    const n = t - this.index;
    if (!n && this.current === s)
      return;
    const r = this.current;
    if (this.index !== t) {
      const i = this._index;
      this._index = t, this.attached && i > 0 != t > 0 && this.sync();
    }
    this.history[t] = s, this.ee.emit("change", {
      navigator: this,
      from: r,
      to: this.current,
      delta: n
    });
  }
  /**
   * Actualizes the `BackButton` visibility state.
   */
  sync() {
    this.postEvent("web_app_setup_back_button", { is_visible: !!this.index });
  }
}
function F({
  params: e,
  ...t
}) {
  return { ...e || { hash: "", search: "" }, ...t };
}
function U(e) {
  const t = typeof e == "string" ? e.startsWith("/") : !!(e.pathname && e.pathname.startsWith("/")), s = L(e);
  return `${t ? s.pathname : s.pathname.slice(1)}${s.search}${s.hash}`;
}
function Q(e, t, s) {
  let n, r;
  typeof e == "string" ? n = e : (n = U(e), s = e.state, r = e.id);
  const { pathname: i, search: o, hash: a } = new URL(n, `http://a${M(t, "/")}`);
  return { id: r, pathname: i, params: { hash: a, search: o, state: s } };
}
async function N(e) {
  return e === 0 ? !0 : Promise.race([
    new Promise((t) => {
      const s = tt("popstate", () => {
        s(), t(!0);
      });
      window.history.go(e);
    }),
    // Usually, it takes about 1ms to emit this event, but we use some buffer.
    new Promise((t) => {
      setTimeout(t, 50, !1);
    })
  ]);
}
async function qs() {
  if (window.history.length <= 1 || (window.history.pushState(null, ""), await N(1 - window.history.length)))
    return;
  let e = await N(-1);
  for (; e; )
    e = await N(-1);
}
function te(e) {
  return L(e).pathname;
}
const Et = 0, Y = 1, Z = 2;
class ee {
  constructor(t, s, { postEvent: n, hashMode: r = "classic", base: i } = {}) {
    c(this, "navigator"), c(this, "ee", new D()), c(this, "hashMode"), c(this, "base"), c(this, "attached", !1), c(this, "onPopState", ({ state: o }) => {
      if (o === null)
        return this.push(this.parsePath(window.location.href));
      o === Et ? window.history.forward() : o === Y && this.back(), o === Z && this.forward();
    }), c(this, "onNavigatorChange", async ({
      to: o,
      from: a,
      delta: h
    }) => {
      this.attached && await this.syncHistory(), this.ee.emit("change", {
        delta: h,
        from: F(a),
        to: F(o),
        navigator: this
      });
    }), c(this, "on", this.ee.on.bind(this.ee)), c(this, "off", this.ee.off.bind(this.ee)), this.navigator = new Os(
      t.map((o) => Q(o, "/")),
      s,
      n
    ), this.navigator.on("change", (o) => {
      this.onNavigatorChange(o);
    }), this.hashMode = r, this.base = te(i || "");
  }
  /**
   * Attaches current navigator to the browser history allowing navigator to manipulate it.
   */
  async attach() {
    this.attached || (this.attached = !0, this.navigator.attach(), window.addEventListener("popstate", this.onPopState), await this.syncHistory());
  }
  /**
   * Goes back in history by 1.
   */
  back() {
    this.navigator.back();
  }
  /**
   * Detaches current navigator from the browser history.
   */
  detach() {
    this.attached = !1, this.navigator.detach(), window.removeEventListener("popstate", this.onPopState);
  }
  /**
   * Goes forward in history.
   */
  forward() {
    return this.navigator.forward();
  }
  /**
   * Current history cursor.
   */
  get index() {
    return this.navigator.index;
  }
  /**
   * Current history item identifier.
   */
  get id() {
    return this.navigator.current.id;
  }
  /**
   * Changes currently active history item index by the specified delta. This method doesn't
   * change index in case, the updated index points to the non-existing history item. This behavior
   * is preserved until the `fit` argument is specified.
   * @param delta - index delta.
   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.
   */
  go(t, s) {
    return this.navigator.go(t, s);
  }
  /**
   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.
   *
   * If "fit" option was specified and index is out of bounds, it will be cut to the nearest
   * bound.
   * @param index - target index.
   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.
   */
  goTo(t, s) {
    this.navigator.goTo(t, s);
  }
  /**
   * Current history item hash.
   * @see URL.hash
   * @example
   * "", "#my-hash"
   */
  get hash() {
    return (this.navigator.current.params || {}).hash || "";
  }
  /**
   * True if navigator has items before the current item.
   */
  get hasPrev() {
    return this.navigator.hasPrev;
  }
  /**
   * True if navigator has items after the current item.
   */
  get hasNext() {
    return this.navigator.hasNext;
  }
  /**
   * Navigation history.
   */
  get history() {
    return this.navigator.history.map(F);
  }
  /**
   * Path, including pathname, search and hash.
   * @example Pathname only.
   * "/pathname"
   * @example Pathname + search.
   * "/pathname?search"
   * @example Pathname + hash.
   * "/pathname#hash"
   * @example Pathname + search + hash.
   * "/pathname?search#hash"
   */
  get path() {
    return U(this);
  }
  /**
   * Current pathname. Always starts with the slash.
   * @see URL.pathname
   * @example
   * "/", "/abc"
   */
  get pathname() {
    return this.navigator.current.pathname;
  }
  /**
   * Depending on the current navigation type, parses incoming path and returns it presented as
   * an object. In other words, this method parses the passed path and returns object, describing
   * how the navigator "sees" it.
   *
   * @example Hash mode is omitted.
   * parsePath('/abc?a=1#hash');
   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }
   * parsePath('http://example.com/abc?a=1#hash');
   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }
   *
   * @example Hash mode is enabled.
   * parsePath('/abc?a=1#tma?is=cool#yeah');
   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }
   * parsePath('http://example.com/abc?a=1#tma?is=cool#yeah');
   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }
   */
  parsePath(t) {
    let s = L(t);
    return this.hashMode && (s = L(s.hash.slice(1))), {
      pathname: s.pathname,
      search: s.search,
      hash: s.hash
    };
  }
  push(t, s) {
    const n = Q(t, this.path), { state: r = s } = n.params;
    this.navigator.push({ ...n, params: { ...n.params, state: r } });
  }
  replace(t, s) {
    const n = Q(t, this.path), { state: r = s } = n.params;
    this.navigator.replace({ ...n, params: { ...n.params, state: r } });
  }
  /**
   * Combines the navigator `base` property with the passed path data applying the navigator
   * navigation mode.
   * @param value - path presented as string or URLLike.
   */
  renderPath(t) {
    const s = (this.base.length === 1 ? "" : this.base) + M(U(t), "/");
    return this.hashMode ? M(s.slice(1), this.hashMode === "classic" ? "#" : "#/") : s;
  }
  /**
   * Synchronizes current navigator state with browser history.
   */
  async syncHistory() {
    window.removeEventListener("popstate", this.onPopState);
    const { state: t } = this, s = this.renderPath(this);
    await qs(), this.hasPrev && this.hasNext ? (window.history.replaceState(Y, ""), window.history.pushState(t, "", s), window.history.pushState(Z, ""), await N(-1)) : this.hasPrev ? (window.history.replaceState(Y, ""), window.history.pushState(t, "", s)) : this.hasNext ? (window.history.replaceState(t, s), window.history.pushState(Z, ""), await N(-1)) : (window.history.replaceState(Et, ""), window.history.pushState(t, "", s)), window.addEventListener("popstate", this.onPopState);
  }
  /**
   * Current query parameters.
   * @see URL.search
   * @example
   * "", "?", "?a=1"
   */
  get search() {
    return (this.navigator.current.params || {}).search || "";
  }
  /**
   * Current history item state.
   */
  get state() {
    return (this.navigator.current.params || {}).state;
  }
}
function Vs(e) {
  e || (e = {});
  const { href: t, hash: s } = window.location;
  let n = U(
    e.hashMode === null ? t : s.includes("?") ? s.slice(1) : `?${s.slice(1)}`
  );
  const r = e.base ? te(e.base) : void 0;
  if (r) {
    if (!n.startsWith(r))
      throw b(
        ye,
        `Path "${n}" expected to be starting with "${r}"`
      );
    n = n.slice(r.length);
  }
  return new ee([n], 0, e);
}
function kn(e) {
  const t = e.match(/#(.+)/);
  return t ? t[1] : null;
}
function Ns(e, t) {
  if (Ft()) {
    const s = sessionStorage.getItem(e);
    if (s)
      try {
        const { index: n, history: r } = JSON.parse(s);
        return new ee(
          r,
          n,
          t
        );
      } catch (n) {
        console.error("Unable to restore hash navigator state.", n);
      }
  }
  return Vs(t);
}
function In(e, t) {
  const s = Ns(e, t), n = () => sessionStorage.setItem(e, JSON.stringify({
    index: s.index,
    history: s.history
  }));
  return s.on("change", n), n(), s;
}
function d(e, t) {
  function s(n) {
    return function(i, o, a) {
      return (h) => {
        const p = {
          ...h,
          [i]: n(o)
        };
        return /* @__PURE__ */ Pt(a, { ...p });
      };
    };
  }
  return [s(e), s(t)];
}
const se = ne(void 0);
function Ds() {
  const e = re(se);
  if (!e)
    throw new Error("useSDK was used outside the SDKProvider.");
  return e;
}
function _(e) {
  function t(n) {
    const r = Ds(), [i, o] = rt(
      n ? void 0 : () => {
        if (ks())
          throw new Error("Using hooks on the server side, you must explicitly specify ssr = true option");
        return r.use(e);
      }
    );
    return S(() => {
      o(r.use(e));
    }, [r]), i;
  }
  function s(n) {
    const r = t(n);
    if (r) {
      if ("error" in r)
        throw r.error;
      return r.result;
    }
  }
  return [t, s];
}
const [Bs, Ms] = _(je), [On, qn] = d(
  Bs,
  Ms
), [Ls, $s] = _(Je), [Vn, Nn] = d(
  Ls,
  $s
), [Hs, Us] = _(Qe), [Dn, Bn] = d(
  Hs,
  Us
), [Ws, Gs] = _(es), [Mn, Ln] = d(
  Ws,
  Gs
), [js, zs] = _(ns), [$n, Hn] = d(
  js,
  zs
), [Ks, Js] = _(is), [Un, Wn] = d(Ks, Js), [Fs, Qs] = _(as), [Gn, jn] = d(Fs, Qs), [Ys, Zs] = _(hs), [zn, Kn] = d(Ys, Zs), [Xs, tn] = _(ds), [Jn, Fn] = d(Xs, tn), [en, sn] = _(gs), [Qn, Yn] = d(en, sn), [nn, rn] = _(bs), [Zn, Xn] = d(nn, rn), [on, an] = _(vs), [tr, er] = d(
  on,
  an
), [cn, hn] = _(Es), [sr, nr] = d(
  cn,
  hn
), [pn, un] = _(Ss), [rr, ir] = d(pn, un);
function or(e) {
  const [t, s] = rt(() => e ? void 0 : nt());
  return S(() => {
    e && s(nt());
  }, []), t;
}
const [ln, dn] = _(xs), [ar, cr] = d(ln, dn), [_n, wn] = _(Ts), [hr, pr] = d(_n, wn);
function ur({ children: e, acceptCustomStyles: t, debug: s }) {
  const n = bt(!0), [r, i] = rt(/* @__PURE__ */ new Map()), o = bt(r), a = ie(
    (p) => {
      n.current && i((C) => (p && p(C), new Map(C)));
    },
    []
  ), h = oe(() => ({
    use(p, ...C) {
      const wt = r.get(p);
      if (wt)
        return wt;
      let m, K;
      try {
        m = p(...C);
      } catch (g) {
        K = g;
      }
      function H(g) {
        return r.set(p, g), g;
      }
      if (K)
        return H({ error: K });
      let I;
      if (Array.isArray(m) && (I = m[1], m = m[0]), !m)
        return H({ result: m, cleanup: I });
      function gt(g) {
        if ("on" in g) {
          const O = g.on("change", () => a()), ft = I;
          I = () => {
            ft && ft(), O();
          };
        }
        return { result: g, cleanup: I };
      }
      return m instanceof Promise ? (m.then(
        (g) => a((O) => O.set(p, gt(g))),
        (g) => a((O) => O.set(p, { error: g }))
      ), H({})) : H(gt(m));
    }
  }), [r]);
  return S(() => (n.current = !0, () => {
    n.current = !1;
  }), []), S(() => {
    if (at())
      return As(t);
  }, [t]), S(() => {
    ue(s || !1);
  }, [s]), S(() => {
    o.current = r;
  }, [r]), S(() => () => {
    o.current.forEach((p) => {
      "cleanup" in p && p.cleanup && p.cleanup();
    });
  }, []), /* @__PURE__ */ Pt(se.Provider, { value: h, children: e });
}
export {
  Ve as BackButton,
  Os as BasicNavigator,
  ze as BiometryManager,
  ee as BrowserNavigator,
  Fe as ClosingBehavior,
  ts as CloudStorage,
  ye as ERR_INVALID_PATH_BASE,
  ge as ERR_INVOKE_CUSTOM_METHOD_RESPONSE,
  _e as ERR_METHOD_PARAMETER_UNSUPPORTED,
  de as ERR_METHOD_UNSUPPORTED,
  me as ERR_NAVIGATION_HISTORY_EMPTY,
  ve as ERR_NAVIGATION_INDEX_INVALID,
  bn as ERR_NAVIGATION_ITEM_INVALID,
  xt as ERR_PARSE,
  mn as ERR_SSR_INIT,
  fe as ERR_TIMED_OUT,
  be as ERR_UNEXPECTED_TYPE,
  we as ERR_UNKNOWN_ENV,
  D as EventEmitter,
  ss as HapticFeedback,
  rs as InitData,
  os as Invoice,
  cs as MainButton,
  ls as MiniApp,
  ws as Popup,
  fs as QRScanner,
  W as SDKError,
  ur as SDKProvider,
  ms as SettingsButton,
  ys as SwipeBehavior,
  Ps as ThemeParams,
  Rs as Utils,
  Cs as Viewport,
  Xe as array,
  Sn as bindMiniAppCSSVars,
  Rn as bindThemeParamsCSSVars,
  xn as bindViewportCSSVars,
  E as boolean,
  qt as captureSameReq,
  st as classNames,
  Te as compareVersions,
  Vs as createBrowserNavigatorFromLocation,
  Ie as createPostEvent,
  L as createSafeURL,
  Lt as date,
  kn as getHash,
  te as getPathname,
  je as initBackButton,
  Je as initBiometryManager,
  Qe as initClosingBehavior,
  es as initCloudStorage,
  ns as initHapticFeedback,
  is as initInitData,
  as as initInvoice,
  hs as initMainButton,
  ds as initMiniApp,
  In as initNavigator,
  gs as initPopup,
  bs as initQRScanner,
  vs as initSettingsButton,
  Es as initSwipeBehavior,
  Ss as initThemeParams,
  xs as initUtils,
  Ts as initViewport,
  As as initWeb,
  V as invokeCustomMethod,
  Bt as isColorDark,
  at as isIframe,
  Ft as isPageReload,
  ct as isRGB,
  Oe as isRGBShort,
  Is as isSDKError,
  An as isSDKErrorOfType,
  ks as isSSR,
  Cn as isTMA,
  v as json,
  yn as mergeClassNames,
  Tn as mockTelegramEnv,
  R as number,
  z as off,
  y as on,
  En as parseInitData,
  lt as parseLaunchParams,
  Zt as parseThemeParams,
  B as postEvent,
  w as request,
  Ke as requestBiometryInfo,
  Pn as requestThemeParams,
  Xt as requestViewport,
  nt as retrieveLaunchParams,
  De as rgb,
  ut as searchParams,
  Ue as serializeLaunchParams,
  Kt as serializeThemeParams,
  P as setCSSVar,
  ue as setDebug,
  vn as setTargetOrigin,
  u as string,
  he as subscribe,
  x as supports,
  ke as targetOrigin,
  Dt as toRGB,
  Rt as unsubscribe,
  U as urlToPath,
  Ms as useBackButton,
  Bs as useBackButtonRaw,
  $s as useBiometryManager,
  Ls as useBiometryManagerRaw,
  Us as useClosingBehavior,
  Hs as useClosingBehaviorRaw,
  Gs as useCloudStorage,
  Ws as useCloudStorageRaw,
  zs as useHapticFeedback,
  js as useHapticFeedbackRaw,
  Js as useInitData,
  Ks as useInitDataRaw,
  Qs as useInvoice,
  Fs as useInvoiceRaw,
  or as useLaunchParams,
  Zs as useMainButton,
  Ys as useMainButtonRaw,
  tn as useMiniApp,
  Xs as useMiniAppRaw,
  sn as usePopup,
  en as usePopupRaw,
  rn as useQRScanner,
  nn as useQRScannerRaw,
  Ds as useSDK,
  an as useSettingsButton,
  on as useSettingsButtonRaw,
  hn as useSwipeBehavior,
  cn as useSwipeBehaviorRaw,
  un as useThemeParams,
  pn as useThemeParamsRaw,
  dn as useUtils,
  ln as useUtilsRaw,
  wn as useViewport,
  _n as useViewportRaw,
  qn as withBackButton,
  On as withBackButtonRaw,
  Nn as withBiometryManager,
  Vn as withBiometryManagerRaw,
  Bn as withClosingBehavior,
  Dn as withClosingBehaviorRaw,
  Ln as withCloudStorage,
  Mn as withCloudStorageRaw,
  Hn as withHapticFeedback,
  $n as withHapticFeedbackRaw,
  Wn as withInitData,
  Un as withInitDataRaw,
  jn as withInvoice,
  Gn as withInvoiceRaw,
  Kn as withMainButton,
  zn as withMainButtonRaw,
  Fn as withMiniApp,
  Jn as withMiniAppRaw,
  Yn as withPopup,
  Qn as withPopupRaw,
  Xn as withQRScanner,
  Zn as withQRScannerRaw,
  er as withSettingsButton,
  tr as withSettingsButtonRaw,
  nr as withSwipeBehavior,
  sr as withSwipeBehaviorRaw,
  ir as withThemeParams,
  rr as withThemeParamsRaw,
  Nt as withTimeout,
  cr as withUtils,
  ar as withUtilsRaw,
  pr as withViewport,
  hr as withViewportRaw
};
//# sourceMappingURL=index.js.map
